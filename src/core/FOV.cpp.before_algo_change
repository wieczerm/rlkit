#include "src/core/FOV.hpp"
#include <algorithm>
#include <cmath>

const int FOV::multXX[8] = {1, 0, 0, -1, -1, 0, 0, 1};
const int FOV::multXY[8] = {0, 1, -1, 0, 0, -1, 1, 0};
const int FOV::multYX[8] = {0, 1, -1, 0, 0, -1, 1, 0};
const int FOV::multYY[8] = {1, 0, 0, 1, -1, 0, 0, -1};

FOV::FOV(const core::IMapView &map)
    : map_(map), width_(static_cast<std::size_t>(map.width())),
      height_(static_cast<std::size_t>(map.height())),
      visible_(height_, std::vector<bool>(width_, false)) {}

void FOV::compute(const Position &origin, int radius) {
  for (auto &row : visible_)
    std::fill(row.begin(), row.end(), false);

  visible_[static_cast<std::size_t>(origin.y)]
          [static_cast<std::size_t>(origin.x)] = true;

  for (int oct = 0; oct < 8; ++oct) {
    castLight(origin.x, origin.y, 1, 1.0, 0.0, radius, multXX[oct], multXY[oct],
              multYX[oct], multYY[oct]);
  }
}

bool FOV::isVisible(int x, int y) const {
  if (x < 0 || static_cast<std::size_t>(x) >= width_ || y < 0 ||
      static_cast<std::size_t>(y) >= height_)
    return false;
  return visible_[static_cast<std::size_t>(y)][static_cast<std::size_t>(x)];
}

void FOV::castLight(int cx, int cy, int row, double startSlope, double endSlope,
                    int radius, int xx, int xy, int yx, int yy) {
  if (startSlope < endSlope)
    return;

  double nextStart = startSlope;
  for (int i = row; i <= radius; ++i) {
    bool blocked = false;
    for (int dx = -i; dx <= 0; ++dx) {
      int dy = -i;
      double lSlope = (static_cast<double>(dx) - 0.5) / (static_cast<double>(dy) + 0.5);
      double rSlope = (static_cast<double>(dx) + 0.5) / (static_cast<double>(dy) - 0.5);

      if (rSlope > startSlope)
        continue;
      if (lSlope < endSlope)
        break;

      int mx = cx + dx * xx + dy * xy;
      int my = cy + dx * yx + dy * yy;

      if (mx < 0 || static_cast<size_t>(mx) >= width_ || my < 0 ||
          static_cast<size_t>(my) >= height_)
        continue;

      bool isBlocking = map_.blocksLos(mx, my);

      if (blocked) {
        if (isBlocking) {
          nextStart = rSlope;
          continue;
        } else {
          blocked = false;
          startSlope = nextStart;
        }
      } else {
        if (std::max(std::abs(dx), std::abs(dy)) <= radius) {
          visible_[static_cast<std::size_t>(my)][static_cast<std::size_t>(mx)] =
              true;
        }

        if (isBlocking && i < radius) {
          blocked = true;
          castLight(cx, cy, i + 1, startSlope, lSlope, radius, xx, xy, yx, yy);
          nextStart = rSlope;
        }
      }
    }
    if (blocked)
      break;
  }
}
