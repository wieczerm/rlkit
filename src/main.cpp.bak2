#include "core/FOV.hpp"
#include "core/InputHandler.hpp"
#include "core/Pathfinding.hpp"
#include "entities/Entity.hpp"
#include "entities/EntityManager.hpp"
#include "entities/TurnManager.hpp"
#include "renderers/FTXUIRenderer.hpp"
#include "src/actions/ActionResult.hpp"
#include "src/actions/MoveAction.hpp"
#include "src/actions/OpenAction.hpp"
#include "src/ai/AIBehavior.hpp"
#include "src/ai/SimpleAI.hpp"
#include "world/Map.hpp"
#include "world/MapViewAdapter.hpp"
#include "world/Tile.hpp"
#include "world/gen/MapGenerator.hpp"
#include "world/gen/RoomsGen.hpp"
#include <cstdio>
#include <format>
#include <fstream>
#include <iostream>
#include <memory>
#include <random>
#include <string>

std::ofstream logfile("debug.log");

inline void LOG(const std::string &msg) {
  logfile << msg << "\n";
  logfile.flush();
}

int main() {
  // Generate map
  constexpr int MAP_W = 60, MAP_H = 40;
  world::Map map(MAP_W, MAP_H, world::Tile::Wall);

  world::MapGenerator gen(12345);
  world::RoomsOptions opts;
  opts.max_rooms = 15;
  opts.room_min = 4;
  opts.room_max = 8;
  opts.add_doors = true;
  gen.generateRooms(map, opts);

  entities::TurnManager turnMgr;

  // Create player
  entities::EntityManager entityMgr;
  auto player = std::make_unique<entities::Entity>("Player", Position{5, 5});
  player->setMaxHP(100);
  player->setHP(100);
  player->setProperty("speed", 100);
  entities::Entity *playerPtr = player.get();
  entityMgr.addEntity(std::move(player));
  turnMgr.addEntity(playerPtr);

  // Create some monsters
  std::mt19937 rng(42);
  int monstersSpawned = 0;
  for (int i = 0; i < 5; ++i) {
    int attempts = 0;
    bool spawned = false;
    while (attempts < 100) {
      int x = 1 + (static_cast<int>(rng()) % (MAP_W - 2));
      int y = 1 + (static_cast<int>(rng()) % (MAP_H - 2));
      if (!map.blocksMovement({x, y}) && !entityMgr.getEntityAt({x, y})) {
        auto monster =
            std::make_unique<entities::Entity>("Goblin", Position{x, y});
        monster->setMaxHP(30);
        monster->setHP(20);
        monster->setProperty("phys_res", 5);
        monster->setProperty("speed", 80);
        monster->setAI(std::make_unique<ai::SimpleAI>(8));
        entities::Entity *monsterPtr = monster.get();
        entityMgr.addEntity(std::move(monster));
        turnMgr.addEntity(monsterPtr);
        ++monstersSpawned;
        spawned = true;
        break;
      }
      ++attempts;
    }
  }

  // Setup systems
  world::MapViewAdapter mapView(map);
  FOV fov(mapView);
  renderers::FTXUIRenderer renderer(40, 25);
  core::InputHandler input;

  std::vector<std::string> messages;
  messages.push_back("Welcome to the dungeon!");
  messages.push_back("Use WASD or vi keys to move, Q to quit");

  // Game loop

  /*std::cout << "Starting game loop...\n";
  std::cout << "Player at: " << playerPtr->getPosition().x << ","
            << playerPtr->getPosition().y << "\n";
  std::cout << "Entities count: " << entityMgr.getEntities().size() << "\n";*/
  // Initial FOV compute BEFORE loop!
  fov.compute(playerPtr->getPosition(), 8);
  std::cout << "FOV computed\n";

  bool running = true;

  while (running) {

    /*std::cout << "Loop iteration start\n";
    core::InputAction action = input.getAction();
    std::cout << "Got action: " << static_cast<int>(action) << "\n";*/

    // 1. Get input
    core::InputAction action = input.getAction();

    if (action == core::InputAction::Quit) {
      running = false;
      break;
    }

    // 2. Handle player action
    bool playerActed = false;

    if (action == core::InputAction::Open) {
      Position target = playerPtr->getPosition();
      // Fix: use else-if chain
      if (world::isDoor(map.at({target.x, target.y + 1}))) {
        target.y += 1;
      } else if (world::isDoor(map.at({target.x, target.y - 1}))) {
        target.y -= 1;
      } else if (world::isDoor(map.at({target.x - 1, target.y}))) {
        target.x -= 1;
      } else if (world::isDoor(map.at({target.x + 1, target.y}))) {
        target.x += 1;
      }

      actions::OpenAction open(*playerPtr, target);
      auto result = open.execute(map);
      messages.clear();
      messages.push_back(result.message);

      if (result.status == actions::ActionStatus::Success) {
        playerActed = true;
      }
    } else if (action == core::InputAction::Wait) {
      messages.clear();
      messages.push_back("You wait...");
      playerActed = true;
    } else if (action != core::InputAction::None) {
      // Movement
      Position delta = core::InputHandler::actionToDirection(action);
      Position newPos = playerPtr->getPosition() + delta;

      actions::MoveAction move(*playerPtr, newPos);
      auto result = move.execute(map, entityMgr);

      messages.clear();
      if (result.status == actions::ActionStatus::Success) {
        messages.push_back(result.message.empty() ? "You move."
                                                  : result.message);
        playerActed = true;
      } else {
        messages.push_back(result.message);
      }
    }

    // 3. If player acted, process turn system
    if (playerActed) {
      LOG("Player acted, processing turn...");
      std::cout << "TurnManager empty? " << turnMgr.isEmpty() << "\n";
      turnMgr.processTurn(); // Consume player turn

      // 4. Process AI turns until player's turn again
      while (!turnMgr.isEmpty()) {
        // std::cout << "AI loop iteration\n";
        entities::Entity *actor = turnMgr.getNextActor();

        if (actor == playerPtr) {
          break; // Back to player
        }

        // AI turn
        if (actor->hasAI()) {
          LOG(std::string("AI acting: ") + std::to_string(actor->getName())
              << " at " << actor->getPosition().x << ","
              << actor->getPosition().y << "\n");

          auto result = actor->getAI()->act(*actor, *playerPtr, map, entityMgr);

          LOG(std::cout << "AI result: " << result.message << "\n");

          if (!result.message.empty()) {
            messages.push_back(result.message);
          }
        }

        turnMgr.processTurn(); // FIX: Consume AI turn
      }
      // std::cout << "AI loop done\n";
      //  5. Update FOV after all actions
      fov.compute(playerPtr->getPosition(), 8);
    }

    // Render
    std::cout << "\033[2J\033[H"; // Clear screen
    renderer.render(map, fov, entityMgr, playerPtr->getPosition());
    renderer.renderStats(playerPtr->getName(), playerPtr->getHP(),
                         playerPtr->getMaxHP());
    renderer.renderMessages(messages);
  }
  std::cout << "\nThanks for playing!\n";
  return 0;
}
